{
  "name": "esp-js",
  "version": "0.0.9",
  "description": "Evented State Processor (ESP) adds specific processing workflow around changes to a model's state",
  "keywords": [
    "state processor",
    "evented state processor",
    "reactive",
    "rx",
    "event loop",
    "complex state processor",
    "router",
    "event router"
  ],
  "main": "dist/esp.js",
  "author": {
    "name": "Keith Woods"
  },
  "license": "Apache 2",
  "repository": {
    "type": "git",
    "url": "https://github.com/esp/esp-js"
  },
  "devDependencies": {
    "babel": "^4.7.16",
    "babel-core": "^4.7.16",
    "babel-loader": "^4.3.0",
    "grunt": "^0.4.5",
    "grunt-babel": "^4.0.0",
    "grunt-banner": "^0.4.0",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-jsdoc": "^0.5.7",
    "grunt-karma": "^0.9.0",
    "grunt-webpack": "^1.0.8",
    "inject-loader": "^1.0.0",
    "karma": "^0.12.32",
    "karma-chrome-launcher": "^0.1.8",
    "karma-jasmine": "^0.3.2",
    "karma-webpack": "^1.3.1",
    "load-grunt-tasks": "^1.0.0",
    "source-map-loader": "^0.1.5",
    "webpack": "^1.8.11",
    "webpack-dev-server": "^1.8.2"
  },
  "dependencies": {
    "node-uuid": "^1.4.3"
  },
  "readme": "[![Build Status](https://travis-ci.org/esp/esp-js.svg?branch=master)](https://travis-ci.org/esp/esp-js)\r\n[![npm](https://img.shields.io/npm/v/esp-js.svg)](https://www.npmjs.com/package/esp-js)\r\n[![Join the chat at https://gitter.im/esp/chat](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/esp/chat?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n**[Installation](#installation)** |\r\n**[Basic usage](#basic-usage)** |\r\n**[Key concepts](#key-concepts)** |\r\n**[Anti Patterns](#anti-patterns)** |\r\n**[Examples](#examples)** |\r\n**[Feature Road Map](#feature-road-map)**\r\n\r\n# Evented State Processor (ESP)\r\n\r\nESP adds specific processing workflow around changes to a model's state. \r\nIt takes ownership of a [single root model](#single-root-model).\r\nThose interested in observing the model's state observe a stream of events from a `Router`.\r\nThose wanting to change a model's state can publish events to the `Router`. \r\nThe `Router` routes events to [`EventProcessors`](#event-processors) responsible for applying the new state using a [state processing workflow](#state-processing-workflow). \r\nOnce the workflow is done, the `Router` dispatches the most recent model version to all model observers.\r\n\r\nThe [single root model](#single-root-model) allows a developer to focus on modeling the problem domain without worrying about infrastructural clutter. \r\nThe router's [observable](#observable-api) event dispatch and [state processing workflow](#state-processing-workflow) allows a developer to compose complex state manipulation logic of smaller units which are executed in a deterministic manner.\r\n\r\n## Symptoms that you might be looking for a state management pattern\r\n\r\n* You are dealing with a large amount of state, complex screens with 20-200+ inputs, various workflows or maybe different representations of the same data.\r\n* Your state shifts in real time, with the real time changes triggering complex logic that needs processing.\r\n* You pass objects to other objects, observe these dependent objects for changes and you sync state amongst them.\r\n* You have a deep inheritance strategy amongst your objects.\r\nYou may even mix in some strategies to further augment behaviour.\r\nIt is hard to deterministically tell where the state is and which code changes it.\r\n* You use some form of event aggregation to send state between objects but do not have central representation of this state.\r\n* On the GUI you've used the MV* range of patterns (MVC, MVVM, MVVMC) and have had issues managing complex state.\r\n\r\nESP aims to solve these problems by providing a model-centric view of all state, it provides a deterministic and ordered process for state modifications.\r\n\r\n## Where can it be used?\r\n\r\nESP can be used on both client and servers, anywhere you have push-based real time state that requires modeling. \r\nWithin your application you may have several independent areas that manage complex state, each of these could be candidates for ESP. \r\n* On the client it can be used to process state for a complex screen or a set of related complex screens. \r\n* It complements the MV* range of patterns by providing a deterministic method to modify and observe state. \r\n* On the server you might use it to model push-based user state and general internal server state, again it provides a deterministic method to modify and observe such state.\r\n\r\n# Installation\r\nInstall from npm: `npm install esp-js --save`.\r\n\r\nIf you're using ES6 with a package manager such as [webpack](https://webpack.github.io) you can import `esp` like this:\r\n\r\n```javascript\r\nimport esp from 'esp-js';\r\nvar router = new esp.Router();\r\n```\r\n\r\nAlternatevely you can reference `dist\\esp.js` or `dist\\esp.min.js` via a `script` tag. These files expose `esp` using the Universal Module Definition (UMD) format. \r\n\r\n# Basic usage\r\n\r\nThe complete code for this basic example can be found with the source: [app.js](src/examples/readme/app.js).\r\n\r\n###Create a simple model\r\n\r\nBelow is a simple example of a single entity model. \r\nIn reality you might reach hundreds of entities with the object graph many levels deep.\r\n\r\n``` javascript\r\nclass Car {\r\n    constructor() {\r\n        this._make = 'Unknown';\r\n        this._color = 'White';\r\n        this._isSportModel = false;\r\n        this._description = '';\r\n        this._price = 0;\r\n    }\r\n    get make() {\r\n        return this._make;\r\n    }\r\n    set make(value) {\r\n        this._make = value;\r\n    }\r\n    get color() {\r\n        return this._color;\r\n    }\r\n    set color(value) {\r\n        this._color = value;\r\n    }\r\n    get isSportModel() {\r\n        return this._isSportModel;\r\n    }\r\n    set isSportModel(value) {\r\n        this._isSportModel = value;\r\n    }\r\n    get description() {\r\n        return this._description;\r\n    }\r\n    set description(value) {\r\n        this._description = value;\r\n    }\r\n    get price() {\r\n        return this._price;\r\n    }\r\n    set price(value) {\r\n        this._price = value;\r\n    }\r\n}\r\n```\r\n\r\n### Create an event processor and observe events\r\n\r\nBelow is a basic [event processor](#event-processors) with a few event subscriptions. \r\nAn event processor is simply something that observes events from the router and modifies the model when an event is delivered.\r\n\r\n``` javascript\r\nclass CarEventProcessor {\r\n    constructor(router) {\r\n        this._router = router;\r\n    }\r\n    start() {\r\n        this._listenForCarMakeChangedEvent();\r\n        this._listenForIsSportModelChangedEvent();\r\n        this._listenForColorModelChangedEvent();\r\n    }\r\n    _listenForCarMakeChangedEvent() {\r\n        this._router\r\n            .getEventObservable('myModelId', 'carMakeChangedEvent')\r\n            .observe((model, event)=> {\r\n                model.make = event.make;\r\n            });\r\n    }\r\n    _listenForIsSportModelChangedEvent() {\r\n        this._router\r\n            .getEventObservable('myModelId', 'isSportModelChangedEvent')\r\n            .observe((model, event) => {\r\n                model.isSportModel = event.isSportModel;\r\n                if(model.isSportModel) {\r\n                    model.cost = 30000;\r\n                } else {\r\n                    model.cost = 20000;\r\n                }\r\n            });\r\n    }\r\n    _listenForColorModelChangedEvent() {\r\n        this._router\r\n            .getEventObservable('myModelId', 'colorChangedEvent')\r\n            .observe((model, event) => {\r\n                model.color = event.color;\r\n            });\r\n    }\r\n}\r\n```\r\n\r\n### Create an event post processor\r\n\r\n[Post processors](#PostEventProcessing) are a unit of work that always runs regardless of the event that were raised. \r\nBeing the last stage in the [state processing workflow](#state-processing-workflow) dramatic changes to the model shouldn't be done here. \r\nThis makes it ideal for aggregate operations. \r\nYou could put the below logic into the above event processor. \r\nHowever if many event processors were touching the model, it is best to put such logic at the end of the workflow.\r\nThis avoids the need for previous steps to try figure out aggregate computation when the model is still a shifting target.\r\n\r\n``` javascript\r\nclass CarPostEventProcessor {\r\n    process(model, event, eventContext) {\r\n        this._updatePrice(model);\r\n        this._updateDescription(model);\r\n    }\r\n    _updatePrice(model) {\r\n        var price = 10000; // base price\r\n        if(model.make === 'BMW') price += 20000;\r\n        if(model.isSportModel) price += 10000;\r\n        model.price = price;\r\n    }\r\n    _updateDescription(model) {\r\n        model.description =\r\n            \"Your new \" +\r\n            (model.isSportModel ? \"sporty \" : \"standard \") +\r\n            \"edition \" +\r\n            model.make +\r\n            \" (\" + model.color + \") \" +\r\n            \"will cost Â£\" +\r\n            model.price;\r\n    }\r\n}\r\n```\r\n\r\n### Create an event raiser and publish some events\r\n\r\nMany different things could impact the state of your model: perhaps a button click on the GUI, the results from an async operation or a timeout. \r\nOn the server it might be a request from the network or new data pushed to the server from upstream services.\r\n\r\nIn this example we'll use a controller that (pretends to) receives data from a view and raise an event to the router. \r\nPublishing the event kicks off the router's [state processing workflow](#state-processing-workflow).\r\n\r\n``` javascript\r\nclass CarScreenController {\r\n    constructor(router) {\r\n        this._router = router;\r\n    }\r\n    start() {\r\n        this._listenForModelChanges();\r\n\r\n        console.log(\"Simulating some user actions over 4 seconds: \");\r\n        setTimeout(() => {\r\n            this._router.publishEvent('myModelId', 'carMakeChangedEvent', { make: 'BMW' });\r\n        }, 0);\r\n        setTimeout(() => {\r\n            this._router.publishEvent('myModelId', 'isSportModelChangedEvent', { isSportModel: true });\r\n        }, 2000);\r\n        setTimeout(() => {\r\n            this._router.publishEvent('myModelId', 'colorChangedEvent', { color: 'blue' });\r\n        }, 2000);\r\n    }\r\n    _listenForModelChanges() {\r\n        this._router\r\n            .getModelObservable('myModelId')\r\n            .observe(model => {\r\n                // you'd sync your view here, for now just dump the description to the console\r\n                console.log(model.description);\r\n            });\r\n    }\r\n}\r\n```\r\n\r\nNote how the controller also listens for model changes as often the event raiser is also interested in the resultant model. \r\nFor example a user may select an option from a drop down, raise the event to process it, then await a refreshed model with further data to display. \r\nIn fact several other unrelated controllers may also be interested in this new data and they too would get it by observing the model.\r\n\r\n###Kick it all off\r\n\r\nFinally we wire everything up, start by creating the router, add the model using a `modelId`, the `model` and optionally an `options` object. \r\n`options` can contain a [`preEventprocessor`](#PreEventProcessing) and/or a [`postEventProcessor`](#PostEventProcessing).\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\nrouter.registerModel('myModelId', new Car(), { postEventProcessor : new CarPostEventProcessor() });\r\n\r\nvar carEventProcessor = new CarEventProcessor(router);\r\nvar carScreenController = new CarScreenController(router);\r\ncarEventProcessor.start();\r\ncarScreenController.start();\r\n```\r\n\r\noutput:\r\n```\r\nSimulating some user actions over 4 seconds:\r\nYour new standard edition BMW (white) will cost Â£30000\r\nYour new sporty edition BMW (white) will cost Â£40000\r\nYour new sporty edition BMW (blue) will cost Â£40000\r\n\r\n```\r\nThis basic example completes the event processing round trip. \r\nControl flows into the router via an event, the router owns routing the event to the processors, then owns dispatching the modified model to observers. \r\nIn a real world example there would be a much larger model, many event raisers, many event processors and many model observers.\r\nAdditionally full usage of the [state processing workflow](#state-processing-workflow) would allow for fine grained control of state against the model.\r\n\r\n# Key concepts\r\n\r\n## Single root model\r\n\r\nA single root model is simply a single instance object hierarchy that models your system. \r\nThe object contains little business logic as event processors own this. \r\nAdditionally they own how the model state shifts/grows/contracts over time (more on this below). \r\nThe root of the model obviously knows about objects below it.\r\nHowever its focus is really on interacting with its direct children, and those children with their own children. \r\nThis interaction is usually quite simplistic (i.e. indexers, lookups etc).\r\n\r\nA model purist may say only *model what's specific to your business domain*. \r\nThis pattern prefers the broader definition *model what's specific to your system*.\r\nThis broader definition encompasses the business domain and additional state relating to how your system currently deals with business state. \r\nThis allows you to:\r\n\r\n+ model version information, perhaps of the entire model or of specific nodes\r\n+ model alert notifications that should be processed by consumers/users\r\n+ model the holding of events that require user confirmation ('Are you sure you want to cancel?')\r\n+ model async operations that may be in flight\r\n+ model validation, either at a specific node or model it for the entire model\r\n+ model the type of change the model has undergone\r\n+ model static data that used to interpret the meaning of the model (services would feed static into the model via events)\r\n+ model exception/error conditions\r\n\r\nSome business logic can exist within your model objects, however (and perhaps deviating from other modeling patterns) model objects should contain little business logic.\r\nIf your model objects contains lots of business logic they soon becomes inflexible as they have to account for all possible permutations or configurations. \r\nRather put the logic in [event processors](#event-processors). \r\nThis allows for the model to remain purely descriptive and allows for event processors to be swapped in and out altering how state is applied to the model. \r\nThe 'model' in the traditional sense now really comprises of the model objects, plus event processors, and these together model the sub-system in addition to the business domain.\r\n\r\n> Initialise as much as possible up front - Redundant conditional logic can be avoided by initialising as much of the model up front. \r\n> If the various parts of the model aren't used just model them as 'disabled'. \r\n> Of course if the model grows and contracts you'd not initialise default values in arrays. (i.e. 5 default products in shopping basket)\r\n> However you would initialise other items such as the cart, the users details, input fields specifics etc.\r\n\r\n## Event Processors\r\n\r\nEvent processors are objects that observe the `Router` for events and apply event state to the model. \r\nThere is no object named `EventProcessor` in the ESP code base, it is simply a naming convention.\r\n\r\nAn processor is typically scoped to align with a node in the graph of the object model. \r\nFor example, you may have an object model to describe a financial product `MyProduct`.\r\n`MyProduct` may have a collection of legs, i.e. `MyProduct.legs`. \r\nThere may be enough functionality for each leg to warrant its own event processor.\r\nIn this case you would instantiate a `LegEventProcessor` object that would own a particular leg on the model, i.e. `myProduct.legs[0]`. \r\nYou can always start with a single Event Processor for your root entity then and break it down using good old fashioned OO composition principles.\r\n\r\n## State processing workflow\r\n\r\nWhen an event is published to the router it starts the state processing workflow. \r\nThe workflow has 3 ordered stages, with each stage offering different benefits depending on what state you want to modify. \r\nThe model can be modified at each stage.\r\nStage 2 can be further split into 3 sub stages that are progressive, i.e. the event may not progress through these 3 stages depending upon how event processors decide to process the event.\r\n\r\n> If there were no stages, processors could simply apply the change to the model then raise a new event for 'reacting' processors to observe, similar for events that need to be verified before proceeding. \r\n> To avoid `eventType` explosion the preview and committed stages are provided around the normal stage.\r\n\r\nAt each stage user code will get a function of signature `(model, event, eventContext) => { }` to interact with.\r\nThe first two parameters are self explanatory. The `eventContext` has some methods that can affect how the event proceeds.\r\n\r\nAny component that receives an event during the event workflow can publish subsequent events.\r\nThese subsequent events will be enqueued and processed in turn by the [Event Loop](#the-event-loop).\r\n\r\nThe below image depicts a simplistic view of this process. \r\nNote that `EventPublisher` and `ModelObserver` are often the same component/class. \r\n\r\n> This diagram doesn't cover many of the aspects covered below, i.e. the 3 event subscription sub stages available to EventProcessors, subsequent event publication nor the purging of the event queues by the [Event Loop](#the-event-loop).\r\n> An expanded representation of the flow can be found [here](docs/FullEventProcessingFlow.png). \r\n\r\n![](docs/EventProcessingFlow.png?raw=true)\r\n\r\nBelow we discuss the various stages.\r\nThe example code uses this simple model:\r\n\r\n``` javascript\r\nclass FruitStore {\r\n    constructor() {\r\n        this._hasExpired = false;\r\n        this._stockCount = 10;\r\n        this._shouldRefreshFromStore = false;\r\n        this._shouldRecalculateInventory = false;\r\n        this._version = 0;\r\n    }\r\n    get version() {\r\n        return this._version;\r\n    }\r\n    set version(value) {\r\n        this._version = value;\r\n    }\r\n    get hasExpired() {\r\n        return this._hasExpired;\r\n    }\r\n    set hasExpired(value) {\r\n        this._hasExpired = value;\r\n    }\r\n    get stockCount() {\r\n        return this._stockCount;\r\n    }\r\n    set stockCount(value) {\r\n        this._stockCount = value;\r\n    }\r\n    get shouldRefreshFromStore() {\r\n        return this._shouldRefreshFromStore;\r\n    }\r\n    set shouldRefreshFromStore(value) {\r\n        this._shouldRefreshFromStore = value;\r\n    }\r\n    get shouldRecalculateInventory() {\r\n        return this._shouldRecalculateInventory;\r\n    }\r\n    set shouldRecalculateInventory(value) {\r\n        this._shouldRecalculateInventory = value;\r\n    }\r\n    toString() {\r\n        return \"Stock count: \" + this.stockCount + \", shouldRefreshFromStore: \" + this.shouldRefreshFromStore + \", shouldRecalculateInventory: \" + this.shouldRecalculateInventory;\r\n    }\r\n}\r\n```\r\n\r\nThe complete code for these examples below can be found [with the source](src/examples/readme/app.js).\r\n\r\n### <a name=\"PreEventProcessing\"></a>  1 Pre event processing\r\n\r\nWhen registering a model with the router you can optionally provide an `options` object with a `preEventProcessor` property.\r\nThis property can either be an object with a `process(model, event, eventContext)` method or a function with signature `(model, event, eventContext) => { }`. \r\nThe processor will be the first thing called. \r\nIt's an ideal place to change state that moves with each tick of model (i.e. the version) or to reset any state that was applied specifically for the last [Event Loop](#the-event-loop). \r\nFor example to clear a user alert, or perhaps clear a collection of messages that were dispatched on the network.\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\n\r\nvar store = new FruitStore();\r\nrouter.registerModel(\r\n    'model1',\r\n    store,\r\n    {\r\n        preEventProcessor : (model, event, eventContext) => {\r\n            model.version++;\r\n        }\r\n    }\r\n);\r\nrouter.publishEvent('model1', 'noopEvent', { });\r\nconsole.log(\"Store version: \" + store.version); // 1;\r\n```\r\n\r\noutput\r\n\r\n```\r\nStore version: 1\r\n```\r\n\r\n### 2 Event Processing\r\n\r\nEvent processors wanting to receive an event during this stage can do so by calling `router.getEventObservable()`, its full signature is:\r\n\r\n``` javascript\r\nvar observable = router.getEventObservable(\r\n    modelId : string,\r\n    eventType : string\r\n    [, stage: string = EventStage.normal]\r\n);\r\n```\r\n\r\nThe call takes the `modelId`, the event type and optionally an `EventStage`. \r\nThe `modelId` should uniquely identify the model, the `eventType` identify that type of event, the optional `stage` parameter tells the router when the handler should be invoked. \r\nThe possible values for `stage` are 'preview', 'normal' and 'committed'. \r\n`EventStage` contains these as properties or you can pass a string. \r\nAll handlers registered with `EventStage.preview` receive the event first, then (if not canceled) all handlers at `EventStage.normal`.\r\nFinally if the event was 'committed', all handlers at `EventStage.committed` will receive it.\r\n\r\nThe call returns an [observable](#observable-api).\r\nIts `observe` method takes an observer and returns an object with a `dispose()` method, calling `dispose()` will remove the event subscription from the router.\r\n\r\nUpon event dispatch the router passes the `model` the `event` and an `eventContext` to the given observer. \r\nIt's likely you'll always take the `model` and `event`, and only take the `eventContext` if you want to alter the default event workflow. \r\nTypically you chain calls on the `observable` together (see examples below).\r\n\r\n#### 2.1 Preview stage\r\n\r\nThe event can be canceled at this stage by calling `eventContext.cancel()`.\r\nOther `EventStage.preview` observers will still receive the event, however it won't be delivered to observers at `EventStage.normal` or `EventStage.committed`.\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\n\r\nvar store = new FruitStore();\r\nrouter.registerModel('model1', store);\r\n\r\nrouter\r\n    .getEventObservable('model1', 'fruitExpiredEvent', esp.EventStage.normal)\r\n    .observe((model, event) => {\r\n        console.log(\"Setting hasExpired to \" + event);\r\n        model.hasExpired = event;\r\n    });\r\n\r\nrouter\r\n    .getEventObservable('model1', 'buyFruitEvent', esp.EventStage.preview)\r\n    .observe((model, event, eventContext) => {\r\n        if(model.hasExpired) {\r\n            console.log(\"Cancelling buyFruitEvent event as all fruit has expired\");\r\n            eventContext.cancel();\r\n        }\r\n    });\r\n\r\nrouter\r\n    .getEventObservable('model1', 'buyFruitEvent', esp.EventStage.normal)\r\n    .observe((model, event) => {\r\n        console.log(\"Buying fruit, quantity: \" + event.quantity);\r\n        model.stockCount -= event.quantity;\r\n    });\r\n\r\nrouter.publishEvent('model1', 'buyFruitEvent', { quantity: 1 });\r\n\r\nconsole.log(\"Stock count: \" + store.stockCount); // \"Stock count: 9\"\r\n\r\nrouter.publishEvent('model1', 'fruitExpiredEvent', true);\r\n\r\nrouter.publishEvent('model1', 'buyFruitEvent', { quantity: 1 });\r\n\r\nconsole.log(\"Stock count: \" + store.stockCount); // still \"Stock count: 9\", previous event was canceled by the preview handler\r\n\r\nrouter.publishEvent('model1', 'fruitExpiredEvent', false);\r\n\r\nrouter.publishEvent('model1', 'buyFruitEvent', { quantity: 1 });\r\n\r\nconsole.log(\"Stock count: \" + store.stockCount); // \"Stock count: 8\"\r\n```\r\n\r\noutput:\r\n\r\n```\r\nBuying fruit, quantity: 1\r\nStock count: 9\r\nSetting hasExpired to true\r\nCanceling buyFruitEvent event as all fruit has expired\r\nStock count: 9\r\nSetting hasExpired to false\r\nBuying fruit, quantity: 1\r\nStock count: 8\r\n```\r\n\r\n#### 2.2 Normal stage\r\n\r\nThe normal stage is where **most of your processing will take place**. \r\nIf you subscribe without a stage the router will defaulted the stage to `EventStage.normal`.\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\n\r\nvar store = new FruitStore();\r\nrouter.registerModel('model1', store);\r\n\r\nvar buyFruitEventSubscription = router\r\n    .getEventObservable('model1', 'buyFruitEvent') // i.e. stage = esp.EventStage.normal\r\n    .observe((model, event) => {\r\n        console.log(\"Buying fruit, quantity: \" + event.quantity);\r\n        model.stockCount -= event.quantity;\r\n    });\r\n\r\nrouter.publishEvent('model1', 'buyFruitEvent', { quantity: 1 });\r\n\r\nconsole.log(\"Stock count: \" + store.stockCount); // \"Stock count: 9\"\r\n\r\nbuyFruitEventSubscription.dispose();\r\n\r\nrouter.publishEvent('model1', 'buyFruitEvent', false);\r\n\r\nconsole.log(\"Stock count: \" + store.stockCount); // still \"Stock count: 9\", event not delivered as subscription removed\r\n```\r\n\r\noutput:\r\n\r\n```\r\nBuying fruit, quantity: 1\r\nStock count: 9\r\nStock count: 9\r\n```\r\n\r\nThe event can be committed at this stage by calling `eventContext.commit()`. \r\nThis method can only be called once within this stage. \r\nIf committed, and once all other `EventStage.normal` observers have received the event, the router will then dispatch the event to observers at the committed stage.\r\n\r\n#### 2.3 Committed stage\r\n\r\nProcessors subscribing at the committed stage should assume that the state in the event was applied to the model by an observer at `EventStage.normal`. \r\nThey can then make reactive decisions regarding state they own, e.g. repopulating other static based on model changes.\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\n\r\nvar store = new FruitStore();\r\nrouter.registerModel('model1', store);\r\n\r\nrouter\r\n    .getEventObservable('model1', 'buyFruitEvent')\r\n    .observe((model, event, eventContext) => {\r\n        console.log(\"Buying fruit, quantity: \" + event.quantity);\r\n        model.stockCount -= event.quantity;\r\n        eventContext.commit();\r\n    });\r\n\r\nrouter\r\n    .getEventObservable('model1', 'buyFruitEvent', esp.EventStage.committed)\r\n    .observe((model, event) => {\r\n        // reacting to the buyFruitEvent we check if the shelf quantity requires refilling\r\n        var shouldRefreshFromStore = model.stockCount < 3;\r\n        console.log(\"Checking if we should refresh from store. Should refresh: \" + shouldRefreshFromStore);\r\n        model.shouldRefreshFromStore = shouldRefreshFromStore;\r\n    });\r\n\r\nrouter\r\n    .getEventObservable('model1', 'buyFruitEvent', esp.EventStage.committed)\r\n    .observe((model, event)=> {\r\n        // given we've sold something we flip a dirty flag which could be used by another\r\n        // // periodic event to determine if we should recalculate inventory\r\n        console.log(\"Flagging inventory recalculate\");\r\n        model.shouldRecalculateInventory = true;\r\n    });\r\n\r\nrouter.publishEvent('model1', 'buyFruitEvent', { quantity: 1 });\r\nconsole.log(store.toString()); // Stock count: 9, shouldRefreshFromStore: false, shouldRecalculateInventory: true\r\n\r\nrouter.publishEvent('model1', 'buyFruitEvent', { quantity: 8 });\r\nconsole.log(store.toString()); // Stock count: 1, shouldRefreshFromStore: true, shouldRecalculateInventory: true\r\n```\r\n\r\noutput:\r\n\r\n```\r\nBuying fruit, quantity: 1\r\nChecking if we should refresh from store. Should refresh: false\r\nFlagging inventory recalculate\r\nStock count: 9, shouldRefreshFromStore: false, shouldRecalculateInventory: true\r\nBuying fruit, quantity: 8\r\nChecking if we should refresh from store. Should refresh: true\r\nFlagging inventory recalculate\r\nStock count: 1, shouldRefreshFromStore: true, shouldRecalculateInventory: true\r\n```\r\n\r\n### <a name=\"PostEventProcessing\"></a> 3 Post event processing\r\n\r\nThe post processing stage always runs. \r\nThis stage is similar to the pre event processing except it runs last. \r\nIt is advised you do not change the shape of the model at this point, it is pretty much done and dusted (for this cycle of the [event loop](#the-event-loop)).\r\nHowever you can perform cross cutting validation, aggregate operations or perhaps model the nature of the change that occurred.\r\nThis can be useful for model observers to filter as appropriate. \r\nThere is an example of a post process [above](#create-an-event-post-processor).\r\n\r\n> Note the `eventContext` this stage receives will contain the last event published to the router for the model in question. \r\n> For example, event 'A' may have been the event that started the workflow, however a processor responding to event 'A' may have published event 'B'.\r\n> If 'B' was the last event published during the event loop then 'B' will be last event set against the `eventContext`.\r\n\r\nEvent publication in this stage is allowed, however it will get processed in a new iteration of the event loop.\r\nThus router will treat this new event as if it is a 'first' event and re-run the workflow for the model in question.\r\n\r\n## Model observation and sync\r\n\r\nAn object can listen for model updates by subscribing to changes for that model id via `router.getModelObservable(modelId)`. \r\nSimilar to `router.getEventObservable(...)`, this call returns an [observable](#observable-api) which will yield changes to the observer.\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\nrouter.registerModel(\"modelId\", { foo: 1 });\r\nrouter\r\n    .getEventObservable('modelId', 'fooChanged')\r\n    .observe((model, event)=> {\r\n        model.foo = event.newFoo;\r\n    });\r\nrouter\r\n    .getModelObservable('modelId')\r\n    .observe(model => {\r\n        console.log(\"Foo is \" + model.foo);\r\n    });\r\nrouter.publishEvent('modelId', 'fooChanged', { newFoo: 2 });\r\n```\r\n\r\noutput\r\n\r\n```\r\nFoo is 2\r\n```\r\n\r\n## The event loop\r\n\r\nThe event loop kicks off once an event is published to the router via `router.publishEvent(...)`. \r\nAny time control flow leaves the router (before the initial call to `publishEvent(...)` returns), it is possible that further events could be raised.\r\nAny subsequent events go onto a backing queue for their respective model.\r\n\r\n### Event queues\r\n\r\nEach model added to the router has its own event queue. \r\nEvery time a call to `publishEvent(...)` occurs the event is placed on the queue for the model in question. \r\nDuring the event workflow any subsequent events raised get placed on the back of the model's event queue.\r\nEvents could be raised by a [`preEventProcessor`](#PreEventProcessing), an [event processors](#event-processors) and/or a [`postEventProcessor`](#PostEventProcessing). \r\nThis means published events are not processed immediately, they're processed in turn. \r\nThis allows the router to finish dealing with the current event, and allows for processors to assume the model is in a state fit for the event currently being processed.\r\nProcessors are not concerned with what is in the backing queue, only with the current event and the current state, making execution deterministic.\r\nWhen the current model's event queue is empty, the router will check the queues for other models and continue until all are empty, it then dispatches the model updates. \r\nIt must again check for any new events and finally when all are processed control flow will return to the initial event publisher.\r\n\r\n### Bypassing the event queue with `router.executeEvent(eventType, event)`\r\n\r\nThere are edge cases when you want an event to be processed immediately rather than going onto the backing queue. \r\nTypically this is the exception rather than the rule because you want all processors to first respond to the current event before moving to the next.\r\n\r\nCalling `router.executeEvent(eventType, event)` will immediately execute the event processors for the model currently being processed. \r\nNote that processors responding to executed events are not allowed to publish further events. \r\nDoing so could move the router too far forward so upon resumption of the prior event, the state isn't that which the processors would expect.\r\n\r\n> If you find yourself relying on this method, it is usually a smell that you're not modeling your problem correctly. \r\n> Nearly all issues can be address with further modeling.\r\n\r\n## Observable API\r\n\r\nAs discussed previously both `router.getEventObservable(...)` and `router.getModelObservable(...)` return an observable object. \r\nThis is modeled on [RxJs's](https://github.com/Reactive-Extensions/RxJS) observable API but with only a few methods included.\r\n\r\n> Why not use Rx?\r\n>\r\n> The push based model of Rx is ideal for pub/sub scenarios where state needs to be combined from many differing streams.\r\n> However the full Rx API isn't suitable as introduction of asynchronicity and other methods that would result in state being held in observable streams would break the deterministic staged workflow that the router owns. \r\n> For example, a deferred model change by way of an asynchronous operation would happen outside of the state processing workflow.\r\n> Then there is no guarantee the model would be still in a state suitable once the deferred event arrives. \r\n> Similarly, for relational operations that combine event streams into state held in observable objects/closures, when a final result yields the underlying model may not be in a state suitable for the target result.\r\n\r\nThe methods on `Observable.prototype` are:\r\n\r\n* `do(action)` : invoke an action each time the stream yields, handy for logging and debugging.\r\n* `take(number)` : completes the stream after the specified number of items have been received.\r\n* `takeUntil(predicate, isInclusive)` : takes items from the stream until the delegate returns true, takes the final item based on the `isInclusive` flag.\r\n* `where(predicate)` : only procures items that match the delegate.\r\n* `beginWork((model, event, eventContext, onResultsReceived) => {})` : experimental, see source for documentation.\r\n\r\nIf you wish you can extend the API by adding your own methods to `Observable.prototype`, see the existing code for an example.\r\n\r\nThe below code demonstrates some similarities of use between the APIs. \r\nNote the function delegate signature on `router.getEventObservable(...)`, its `observe` function takes 3 parameters, the `model`, an `event` and optionally the `eventContext`.\r\nThis differs from the single object with the Rx implementation. \r\nThe `subscribe` method is called `observe` to avoid confusion with existing code.\r\n\r\n``` javascript\r\n// note there are several concerns here that would exist in different\r\n// objects within your architecture, they are all together here to demo the concepts.\r\nvar router = new esp.Router();\r\n\r\n// add a basic model\r\nrouter.registerModel(\r\n    \"modelId\",\r\n    {\r\n        staticData:\r\n        {\r\n            initialised: false,\r\n            clientMargin: 0\r\n        },\r\n        price: 0\r\n    }\r\n);\r\n\r\n// create an event stream that listens for static data\r\nvar staticDataSubscriptionDisposable = router\r\n    .getEventObservable('modelId', 'staticDataReceivedEvent')\r\n    .observe((model, event) => {\r\n        console.log(\"Static data received\");\r\n        model.staticData.initialised = true;\r\n        model.staticData.clientMargin = event.clientMargin;\r\n    }\r\n);\r\n\r\n// create an event stream that listens for prices\r\nvar eventSubscriptionDisposable = router\r\n    .getEventObservable('modelId', 'priceReceivedEvent')\r\n    // run an action when the stream yields\r\n    .do((model, event, eventContext) => console.log(\"Price received\"))\r\n    // only procure the event if the condition matches\r\n    .where((model, event, eventContext) => model.staticData.initialised)\r\n    .observe((model, event, eventContext) => {\r\n        model.newPrice =\r\n            event.price +\r\n            model.staticData.clientMargin;\r\n        console.log(\"Price with margin was set to \" + model.newPrice);\r\n    });\r\n\r\n// publish some prices, the first 2 will get ignored as the .where() waits until the\r\n// static data has been set on the model.\r\nrouter.publishEvent('modelId', 'priceReceivedEvent', { price: 100 });\r\nrouter.publishEvent('modelId', 'priceReceivedEvent', { price: 101 });\r\nrouter.publishEvent('modelId', 'staticDataReceivedEvent', { clientMargin: 10 });\r\nrouter.publishEvent('modelId', 'priceReceivedEvent', { price: 102 });\r\n\r\n// clean up code\r\nstaticDataSubscriptionDisposable.dispose();\r\neventSubscriptionDisposable.dispose();\r\n\r\n// this one never gets delivered as we've disposed the event subscriptions\r\nrouter.publishEvent('modelId', 'priceReceivedEvent', { price: 103 });\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nPrice received\r\nPrice received\r\nStatic data received\r\nPrice received\r\nPrice with margin was set to 112\r\n```\r\n\r\n## Asynchronous operations\r\n\r\nIf an asynchronous operation has to be performed, its relating state should be stored on the model. \r\nFor example you'd model that you're about to perform the request, you'd then carry out the request async. \r\nThe router would dispatch an intermittent update so model observers know the model is busy.\r\nThen when results are received you post the results via an event to the router.\r\nThe [`EventProcessor`](#event-processors) would then update the model with the results and denote the async operation has finished.\r\n\r\nThere is a long and a short way to do this, the long involves multiple differing events and 'work items'.\r\nThe short way involves using `beginWork()` which exists on `Observable.prototype` and does the work for you.\r\n\r\nNote: there will be future improvements in this area and hopefully some tie in with external libraries that provide async APIs (i.e. [Rx](https://github.com/Reactive-Extensions/RxJS), [async](https://github.com/caolan/async)).\r\n\r\n### Observable.prototype.beginWork() (beta API)\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\nrouter.registerModel(\"modelId\", { isBusy: false, staticData:false });\r\nrouter\r\n    .getEventObservable('modelId', 'initialiseEvent')\r\n    .beginWork((model, event, eventContext, onResultsReceived) => {\r\n        console.log(\"Getting static data async\");\r\n        model.isBusy = true;\r\n        setTimeout(() =>{\r\n            console.log(\"Static returned\");\r\n            onResultsReceived({staticData:\"MyStaticData\"});\r\n        }, 1000);\r\n    })\r\n    .observe((model, event) => {\r\n            model.isBusy = false;\r\n            var asyncWorkCompleteEvent = event;\r\n            console.log(\r\n                \"Static data received:\",\r\n                asyncWorkCompleteEvent.results.staticData\r\n            );\r\n        }\r\n    );\r\nrouter.getModelObservable('modelId').observe(\r\n    model => {\r\n        if(model.isBusy) {\r\n            console.log(\"GUIs busy, static data: \" + model.staticData);\r\n        }\r\n        else {\r\n            console.log(\"GUIs idle, static data: \" + model.staticData);\r\n        }\r\n    }\r\n);\r\nconsole.log(\"Publishing initialiseEvent\");\r\nrouter.publishEvent('modelId', 'initialiseEvent', {});\r\nconsole.log(\"initialiseEvent published\");\r\n```\r\n\r\noutput:\r\n\r\n```\r\nPublishing initialiseEvent\r\nGetting static data async\r\nGUIs busy, static data: false\r\ninitialiseEvent published\r\nStatic returned\r\nStatic data received: MyStaticData\r\nGUIs idle, static data: false\r\n```\r\n\r\n### Work items\r\n\r\nA work item is simply an object that manages the lifetime of one or many async operations that together could be thought of as a single unit of work. \r\nThere is no object named `workItem` in the ESP code base, it is simply a related pattern for dealing with async operations. \r\nThey work in much the same was as `Observable.prototype.beginWork()` whereby results are posted back to the router.\r\nUsually, but not always, the results would get processed by the event processor that started the work item.\r\n\r\nTypically you'd find that work items fall under one of the following categories:\r\n\r\n* transient : something you create for a short lived operation, perhaps to request a price from the server.\r\nOnce the result is received it has done its job.\r\n* long lived : something that posts multiple results (via events) back into the router.\r\nIt could potentially share its lifetime with the model root (i.e. common static data feed from downstream) or part of the model (i.e. user specific trade filter subscription).\r\n\r\nThis example demonstrate a transient work item:\r\n\r\n``` javascript\r\nclass GetUserStaticDataWorkItem extends esp.model.DisposableBase {\r\n    constructor(router) {\r\n        super();\r\n        this._router = router;\r\n    }\r\n    start() {\r\n        setTimeout(() => {\r\n            console.log(\"Sending results event for StaticDataA\");\r\n            this._router.publishEvent('modelId', 'userStaticReceivedEvent', \"StaticDataA\");\r\n        }, 1000);\r\n        setTimeout(() => {\r\n            console.log(\"Sending results event for StaticDataB\");\r\n            this._router.publishEvent('modelId', 'userStaticReceivedEvent', \"StaticDataB\");\r\n        }, 2000);\r\n    }\r\n}\r\n\r\nclass StaticDataEventProcessor extends esp.model.DisposableBase {\r\n    constructor(router) {\r\n        super();\r\n        this._router = router;\r\n    }\r\n    initialise() {\r\n        this._listenForInitialiseEvent();\r\n        this._listenForStaticDataReceivedEvent();\r\n    }\r\n    _listenForInitialiseEvent() {\r\n        this.addDisposable(this._router\r\n            .getEventObservable('modelId', 'initialiseEvent')\r\n            .take(1)\r\n            .observe(() => {\r\n                console.log(\"Starting work item to get static data\");\r\n                var getUserStaticWorkItem = new GetUserStaticDataWorkItem(this._router);\r\n                this.addDisposable(getUserStaticWorkItem);\r\n                getUserStaticWorkItem.start();\r\n            })\r\n        );\r\n    }\r\n    _listenForStaticDataReceivedEvent() {\r\n        // note you could wire up more advanced disposal of this stream (i.e. use\r\n        // a .takeUntil(), you could also leave it open if you were to later\r\n        // expect events matching its eventType\r\n        this.addDisposable(this._router\r\n            .getEventObservable('modelId', 'userStaticReceivedEvent')\r\n            .observe((model, event, eventContext) => {\r\n                console.log(\"Adding static data [\" + event + \"] to model\");\r\n                model.staticData.push(event);\r\n            })\r\n        );\r\n    }\r\n}\r\n\r\nvar router = new esp.Router();\r\nrouter.registerModel(\"modelId\", { staticData:[]});\r\nvar staticDataEventProcessor = new StaticDataEventProcessor(router);\r\nstaticDataEventProcessor.initialise();\r\nconsole.log(\"Sending initialiseEvent\");\r\nrouter.publishEvent('modelId', 'initialiseEvent', {});\r\n```\r\n\r\noutput :\r\n\r\n```\r\nSending initialiseEvent\r\nStarting work item to get static data\r\nSending results event for StaticDataA\r\nAdding static data [StaticDataA] to model\r\nSending results event for StaticDataB\r\nAdding static data [StaticDataB] to model\r\n```\r\n\r\n## Error Flows\r\n\r\nIf an exception is unhandled during the event processing workflow the router will halt. \r\nAny further usage results in the initial error being wrapped and rethrown.\r\n\r\nIf an observable stream (returned from `router.getEventObservable(...)` or `router.getModelObservable(...)`) has an exception, its `onError` handler will be called.\r\nThis allows the developer to log a more detailed exception based on the streams details.\r\nIt also allows for errors in observable methods to propagate to the error handler provided to the `.observe()` call. \r\nAny error will halt the router, no further observers will receive the current or subsequent events/model updates.\r\n\r\n``` javascript\r\nvar router = new esp.Router();\r\nrouter.registerModel(\"modelId\", { });\r\nrouter\r\n    .getEventObservable('modelId', 'boomEvent')\r\n    .do(() => {throw new Error(\"Boom\");})\r\n    .observe(\r\n        () => {\r\n            console.log(\"This never run\");\r\n        },\r\n        err => {\r\n            console.log(\"Error in stream: \" + err.message);\r\n        }\r\n    );\r\ntry {\r\n    router.publishEvent('modelId', 'boomEvent', {});\r\n} catch(err) {\r\n    console.log(\"Error caught: \" + err.message);\r\n}\r\n// this won't make it to any observers as the router is halted\r\ntry {\r\n    router.publishEvent('modelId', 'boomEvent', {});\r\n} catch(err) {\r\n    console.log(\"Error caught 2: \" + err.message);\r\n}\r\n```\r\n\r\noutput :\r\n\r\n```\r\nError in stream: Boom\r\n[Router] [ERROR]: Router halted error: [Error: Boom]\r\nError caught: Boom\r\nError caught 2: Event router halted due to previous error [Error: Boom]\r\n```\r\n\r\n## Immutability\r\n\r\nIf you're subscribing to events via `router.getEventObservable(...)`, or listening to model changes via `router.getModelObservable(...)`, misbehaving code could store a copy of the model. \r\nAs the model is single instance the misbehaving code could modify it outside of the event workflow. \r\nTo protect against this you can implement `lock()/unlock()` on your model to get some protection. \r\nIt requires you make your setters throw if a change happens when in the locked state (of course being Javascript you can change anything anytime so do your best to protect against this). \r\nThere are 2 objects in the source, `esp.model.ModelBaseRoot` and `esp.model.ModelBase` that implement the `lock()/unlock()` pattern. \r\nThis would be a reasonable place to start. \r\nAnother option would be to look into cloning the model, however it may have performance issues depending on the size of the model and the frequency of model ticks.\r\n\r\n``` javascript\r\nclass NumericalInput extends esp.model.ModelBase {\r\n    constructor() {\r\n        super();\r\n        this._notional = 0;\r\n    }\r\n    get notional() {\r\n        return this._notional;\r\n    }\r\n    set notional(value) {\r\n        this.ensureLocked();\r\n        this._notional = value;\r\n    }\r\n}\r\n\r\nclass Leg extends esp.model.ModelBase {\r\n    constructor(number) {\r\n        super();\r\n        this._number = number;\r\n        this._currencyPair = \"\";\r\n        this._notionalField = new NumericalInput();\r\n    }\r\n    get number() {\r\n        return this._number;\r\n    }\r\n    get currencyPair() {\r\n        return this._currencyPair;\r\n    }\r\n    set currencyPair(value) {\r\n        this.ensureLocked();\r\n        this._currencyPair = value;\r\n    }\r\n    get notionalField() {\r\n        return this._notionalField;\r\n    }\r\n}\r\n\r\nclass Tile extends esp.model.ModelRootBase {\r\n    constructor() {\r\n        super();\r\n        this._leg1 = new Leg(1);\r\n        this._leg2 = new Leg(2);\r\n    }\r\n    get leg1() {\r\n        return this._leg1;\r\n    }\r\n    get leg2() {\r\n        return this._leg2;\r\n    }\r\n}\r\n\r\nvar tile = new Tile();\r\n// bindLockPredicate() recursively sets a predicate on all instance of ModelBase\r\n// that points to the model root, they can use this\r\n// in setters to guard against unwarranted changes,\r\n// if the model expands/contracts you'd have to call it again\r\ntile.bindLockPredicate();\r\ntile.lock();\r\ntry {\r\n    tile.leg1.notionalField.notional = 4;\r\n} catch (err) {\r\n    console.log(\"ERROR: \" + err.message);\r\n}\r\ntile.unlock();\r\ntile.leg1.notionalField.notional = 4;\r\nconsole.log(\"Notional is \" + tile.leg1.notionalField.notional);\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nERROR: Model is locked, can't edit\r\nNotional is 4\r\n```\r\n\r\n# Anti patterns\r\n\r\n## Holding state outside the model\r\n\r\nIf your event processors are holding state, that state should be on the model. \r\nThey may decide to hold instances of work items that are long lived.\r\nPerhaps these instances get disposed with the processor.\r\nHowever information relating to the progress state of the work items should be on the model, it is something others may want to react to (i.e. display a 'busy gui').\r\n\r\n## Having dependent event processors\r\n\r\nIf you publish an event that requires a response from another processor, then perhaps these 2 processors are really dealing with the same concern and need to be merged.\r\n\r\nYou may have a complex sub system within the model.\r\nThis sub system might be better managed behind a faÃ§ade that receives all events and calls methods on the faÃ§ade to manipulate model state.\r\n\r\n## Having circular dependencies between models\r\n\r\nIf you register 2 models and publish events from one to the other that's fine, however if you then find your self publishing back the other you may see some issues.\r\n\r\nIt depends on what you do, you just need to be careful to avoid event reentrancy.\r\n\r\n## Storing a local copy of the model\r\n\r\nIf you're subscribing to events via `router.getEventObservable(...)` or listening to model changes via `router.getModelObservable(...)`, you shouldn't hold a local copy of the model.\r\nYou should only react to change when the stream yields. \r\nMore information on this in the [immutability section](#immutability).\r\n\r\n## Event processors subscribing to model changes\r\n\r\nEvent processors receive the model along with events by subscribing to `router.getEventObservable(...)`.\r\nThey should not listen to model changes via `router.getModelObservable(...)`.\r\nThese two concerns are on different sides of the model boundary. \r\nThere is nothing physically stopping this, it is just an anti pattern and should be avoided.\r\n\r\n# Examples\r\n\r\nThere is already a basic example in the _src_ in addition to all the examples in this _readme_. \r\nOn the road map is an example that covers each of the below areas in details.\r\nIt will give an idea how you can lay out a complex systems model. \r\nThe example will model a complex GUI screen and cover these topics:\r\n\r\n+ Creating a model\r\n    + Immutability\r\n    + Modeling what changed\r\n    + Versioning static data\r\n    + Holding events for users confirmation\r\n    + Multiple models & sharing model entities\r\n+ Bootstrapping and initialising the system\r\n    + Model hydration\r\n    + Model persistence\r\n    + Container usage\r\n    + Growing and contracting models\r\n+ Event workflow specifies\r\n    + Pre event processors\r\n    + EventProcessors\r\n        + Aligning event processors with the model\r\n        + Layout out an event processor\r\n        + Disposing an event processor\r\n        + Sharing common event processors with different models\r\n    + Async operations\r\n        + with .beginWork\r\n        + with work items\r\n        + with pipelines\r\n    + Post event processors\r\n+ Miscellaneous\r\n    + Event context customisation\r\n    + FaÃ§ade pattern for a sub system\r\n    + Synchronising the GUI with new model state\r\n        ++ avoid triggering event during GUI sync\r\n\r\n# Feature Road Map\r\n\r\nv0.0.2\r\n\r\n+ Better async support with pipelines: i.e. a chaining API that can delegate to 3rd part async libraries and handles marshalling async results back through the [state processing workflow](#state-processing-workflow).\r\n+ Event reentrancy detection.\r\n+ Memory leak and performance analysis/improvements.\r\n+ Better model composition and reusability by allowing [`EventProcessors`](#event-processors) to subscribe to a node of a greater model.\r\n\r\n\r\n",
  "readmeFilename": "ReadMe.md",
  "bugs": {
    "url": "https://github.com/esp/esp-js/issues"
  },
  "homepage": "https://github.com/esp/esp-js",
  "_id": "esp-js@0.0.9",
  "_shasum": "5c5baf23c39f8403bb454a4bd439155c034daf87",
  "_resolved": "https://registry.npmjs.org/esp-js/-/esp-js-0.0.9.tgz",
  "_from": "esp-js@0.0.9"
}
